{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NextFlow Documentation","text":"<p>Welcome to Shian's unofficial NextFlow documentation site.</p> <p>Use the navigation menu to explore available topics, including operator documentation and usage guides.</p> <ul> <li>Operators</li> </ul>"},{"location":"Operators/","title":"Operators","text":"<p>This page will document the available operators in NextFlow.</p>"},{"location":"Operators/#transformation-operators","title":"\ud83d\udd04 Transformation Operators","text":"<p>These operators apply functions to each item in a channel, producing a new channel with transformed data. Use them to modify, aggregate, or restructure data as it flows through your pipeline.</p>"},{"location":"Operators/#map","title":"map","text":"<p>Use <code>map</code> to transform each item in a channel, such as converting formats, scaling values, or extracting fields.</p> <ul> <li>Input: A channel emitting any type of item.</li> <li>Output: A channel emitting the result of applying a function to each input item.</li> </ul> <pre><code>Channel.of(1, 2, 3)\n  .map { it * 2 }\n  .view() // Output: 2, 4, 6\n</code></pre> <p>See also: <code>flatMap</code>. While <code>map</code> transforms each item individually, <code>flatMap</code> can emit multiple items for each input by flattening collections. Example (difference from <code>flatMap</code>):</p> <pre><code>// map emits a list as a single item\nChannel.of([1, 2], [3, 4])\n  .map { it }\n  .view() // Output: [1, 2], [3, 4]\n// flatMap emits each element of the list as a separate item\nChannel.of([1, 2], [3, 4])\n  .flatMap { it }\n  .view() // Output: 1, 2, 3, 4\n</code></pre>"},{"location":"Operators/#flatmap","title":"flatMap","text":"<p>Use <code>flatMap</code> to expand nested lists or split items into multiple outputs for further processing.</p> <ul> <li>Input: A channel emitting collections or items that can be expanded.</li> <li>Output: A channel emitting each element from the collections, flattened into a single stream.</li> </ul> <pre><code>Channel.of([1, 2], [3, 4])\n  .flatMap { it }\n  .view() // Output: 1, 2, 3, 4\n</code></pre> <p>See also: <code>map</code>. Use <code>flatMap</code> when your transformation returns collections and you want to emit their elements individually, unlike <code>map</code> which emits the collection as a single item. Example (difference from <code>map</code>):</p> <pre><code>// flatMap emits each element of the list as a separate item\nChannel.of([1, 2], [3, 4])\n  .flatMap { it }\n  .view() // Output: 1, 2, 3, 4\n// map emits a list as a single item\nChannel.of([1, 2], [3, 4])\n  .map { it }\n  .view() // Output: [1, 2], [3, 4]\n</code></pre>"},{"location":"Operators/#collect","title":"collect","text":"<p>Use <code>collect</code> to gather all items into a single collection for summary operations or final output.</p> <ul> <li>Input: A channel emitting any type of item.</li> <li>Output: A channel emitting a single list containing all input items.</li> </ul> <pre><code>Channel.of(1, 2, 3)\n  .collect()\n  .view() // Output: [1, 2, 3]\n</code></pre> <p>See also: <code>toList</code>. Both aggregate all items into a list, but <code>collect</code> is more general and can be customized for other types of aggregation. Example (difference from <code>toList</code>):</p> <pre><code>// collect can be customized for other aggregations\nChannel.of(1, 2, 3)\n  .collect { acc, val -&gt; acc + val * 2 }\n  .view() // Output: [2, 4, 6]\n// toList always collects all items into a list\nChannel.of(1, 2, 3)\n  .toList()\n  .view() // Output: [1, 2, 3]\n</code></pre>"},{"location":"Operators/#flatten","title":"flatten","text":"<p>Use <code>flatten</code> to remove one level of nesting from channel items, useful after aggregation or grouping.</p> <ul> <li>Input: A channel emitting nested collections.</li> <li>Output: A channel emitting all elements from the nested collections as a flat stream.</li> </ul> <pre><code>Channel.of([1, 2], [3, 4])\n  .flatten()\n  .view() // Output: 1, 2, 3, 4\n</code></pre> <p>See also: <code>flatMap</code>. Both flatten nested collections, but <code>flatMap</code> applies a transformation before flattening, while <code>flatten</code> only removes one level of nesting. Example (difference from <code>flatMap</code>):</p> <pre><code>// flatten removes one level of nesting, but does not apply a transformation\nChannel.of([1, 2], [3, 4])\n  .flatten()\n  .view() // Output: 1, 2, 3, 4\n// flatMap applies a transformation and flattens\nChannel.of([1, 2], [3, 4])\n  .flatMap { it }\n  .view() // Output: 1, 2, 3, 4\n</code></pre>"},{"location":"Operators/#tolist","title":"toList","text":"<p>Use <code>toList</code> to collect all items for batch processing or output as a single list.</p> <ul> <li>Input: A channel emitting any type of item.</li> <li>Output: A channel emitting a single list of all items, similar to <code>collect</code>.</li> </ul> <pre><code>Channel.of('a', 'b', 'c')\n  .toList()\n  .view() // Output: ['a', 'b', 'c']\n</code></pre> <p>See also: <code>collect</code>. Both gather all items into a list, but <code>toList</code> is a convenience method for this specific case. Example (difference from <code>collect</code>):</p> <pre><code>// toList always collects all items into a list\nChannel.of(1, 2, 3)\n  .toList()\n  .view() // Output: [1, 2, 3]\n// collect can be customized for other aggregations\nChannel.of(1, 2, 3)\n  .collect { acc, val -&gt; acc + val * 2 }\n  .view() // Output: [2, 4, 6]\n</code></pre>"},{"location":"Operators/#tosortedlist","title":"toSortedList","text":"<p>Use <code>toSortedList</code> to collect and sort all items, such as for reporting or ordered output.</p> <ul> <li>Input: A channel emitting comparable items.</li> <li>Output: A channel emitting a single sorted list of all items.</li> </ul> <pre><code>Channel.of(3, 1, 2)\n  .toSortedList()\n  .view() // Output: [1, 2, 3]\n</code></pre> <p>See also: <code>toList</code>. <code>toSortedList</code> sorts the items, while <code>toList</code> preserves their original order. Example (difference from <code>toList</code>):</p> <pre><code>// toSortedList sorts the items\nChannel.of(3, 1, 2)\n  .toSortedList()\n  .view() // Output: [1, 2, 3]\n// toList preserves order\nChannel.of(3, 1, 2)\n  .toList()\n  .view() // Output: [3, 1, 2]\n</code></pre>"},{"location":"Operators/#filtering-operators","title":"\ud83e\uddf9 Filtering Operators","text":"<p>These operators filter items in a channel based on specified conditions. Use them to select, limit, or exclude data as it flows through your pipeline.</p>"},{"location":"Operators/#filter","title":"filter","text":"<p>Use <code>filter</code> to select items that meet specific criteria, such as filtering by value, pattern, or type.</p> <ul> <li>Input: A channel emitting any type of item.</li> <li>Output: A channel emitting only items that match the given predicate (closure, regex, or type).</li> </ul> <pre><code>// By closure\nChannel.of(1, 2, 3, 4)\n  .filter { it % 2 == 0 }\n  .view() // Output: 2, 4\n// By regex\nChannel.of('apple', 'banana', 'apricot')\n  .filter(/^a.*/)\n  .view() // Output: apple, apricot\n// By type\nChannel.of(1, 'a', 2, 'b')\n  .filter(Number)\n  .view() // Output: 1, 2\n</code></pre> <p>See also: <code>take</code>, <code>skip</code>. While <code>filter</code> selects items based on a condition, <code>take</code> and <code>skip</code> select items based on their position in the stream. Example (difference from <code>take</code> and <code>skip</code>):</p> <pre><code>// filter selects items by condition\nChannel.of(1, 2, 3, 4)\n  .filter { it &gt; 2 }\n  .view() // Output: 3, 4\n// take selects by position\nChannel.of(1, 2, 3, 4)\n  .take(2)\n  .view() // Output: 1, 2\n// skip ignores by position\nChannel.of(1, 2, 3, 4)\n  .skip(2)\n  .view() // Output: 3, 4\n</code></pre>"},{"location":"Operators/#take","title":"take","text":"<p>Use <code>take</code> to limit the number of items processed downstream, such as for sampling or testing.</p> <ul> <li>Input: A channel emitting any type of item.</li> <li>Output: A channel emitting only the first N items.</li> </ul> <pre><code>Channel.of('a', 'b', 'c', 'd')\n  .take(2)\n  .view() // Output: 'a', 'b'\n</code></pre> <p>See also: <code>skip</code>, <code>filter</code>. <code>take</code> emits the first N items, while <code>skip</code> ignores the first N. Use <code>filter</code> for condition-based selection. Example (difference from <code>filter</code> and <code>skip</code>):</p> <pre><code>// take emits the first N items\nChannel.of('a', 'b', 'c', 'd')\n  .take(2)\n  .view() // Output: 'a', 'b'\n// filter emits items matching a condition\nChannel.of('a', 'b', 'c', 'd')\n  .filter { it &gt; 'b' }\n  .view() // Output: 'c', 'd'\n// skip ignores the first N items\nChannel.of('a', 'b', 'c', 'd')\n  .skip(2)\n  .view() // Output: 'c', 'd'\n</code></pre>"},{"location":"Operators/#skip","title":"skip","text":"<p>Use <code>skip</code> to ignore a fixed number of initial items, such as skipping headers or warm-up data.</p> <ul> <li>Input: A channel emitting any type of item.</li> <li>Output: A channel emitting all items except the first N.</li> </ul> <pre><code>Channel.of(10, 20, 30, 40)\n  .skip(2)\n  .view() // Output: 30, 40\n</code></pre> <p>See also: <code>take</code>. <code>skip</code> ignores the first N items, while <code>take</code> emits only the first N. Example (difference from <code>take</code>):</p> <pre><code>// skip ignores the first N items\nChannel.of(10, 20, 30, 40)\n  .skip(2)\n  .view() // Output: 30, 40\n// take emits only the first N items\nChannel.of(10, 20, 30, 40)\n  .take(2)\n  .view() // Output: 10, 20\n</code></pre>"},{"location":"Operators/#combining-operators","title":"\ud83d\udd17 Combining Operators","text":"<p>These operators combine data from multiple channels. Use them to merge, join, or relate data streams for complex workflows.</p>"},{"location":"Operators/#mix","title":"mix","text":"<p>Use <code>mix</code> to merge multiple data sources into a single stream for unified processing.</p> <ul> <li>Input: Two or more channels emitting any type of item.</li> <li>Output: A single channel emitting all items from the input channels, in the order they become available.</li> </ul> <pre><code>Channel\n  .mix(Channel.of(1, 2), Channel.of(3, 4))\n  .view() // Output: 1, 2, 3, 4 (order may vary)\n</code></pre> <p>See also: <code>concat</code>. Both merge multiple channels, but <code>mix</code> emits items as soon as they are available from any input, while <code>concat</code> emits all items from one channel before moving to the next. Example (difference from <code>concat</code>):</p> <pre><code>// mix interleaves items as they arrive\nChannel.mix(Channel.of(1, 2), Channel.of(10, 20))\n  .view() // Output: 1, 10, 2, 20 (order may vary)\n// concat preserves channel order\nChannel.concat(Channel.of(1, 2), Channel.of(10, 20))\n  .view() // Output: 1, 2, 10, 20\n</code></pre>"},{"location":"Operators/#concat","title":"concat","text":"<p>Use <code>concat</code> to chain channels together in a specific order, such as appending results or logs.</p> <ul> <li>Input: Two or more channels emitting any type of item.</li> <li>Output: A single channel emitting all items from the first channel, then all items from the next, and so on.</li> </ul> <pre><code>Channel\n  .concat(Channel.of('a', 'b'), Channel.of('c', 'd'))\n  .view() // Output: 'a', 'b', 'c', 'd'\n</code></pre> <p>See also: <code>mix</code>. Use <code>concat</code> when you need to preserve the order of channels, unlike <code>mix</code> which interleaves items as they arrive. Example (difference from <code>mix</code>):</p> <pre><code>// concat emits all items from the first channel, then the next\nChannel.concat(Channel.of('a', 'b'), Channel.of('x', 'y'))\n  .view() // Output: 'a', 'b', 'x', 'y'\n// mix interleaves items as they become available\nChannel.mix(Channel.of('a', 'b'), Channel.of('x', 'y'))\n  .view() // Output: 'a', 'x', 'b', 'y' (order may vary)\n</code></pre>"},{"location":"Operators/#combine","title":"combine","text":"<p>Use <code>combine</code> to relate or synchronize data from two sources based on a common identifier.</p> <ul> <li>Input: Two channels emitting tuples or lists, with a key to match items.</li> <li>Output: A channel emitting pairs of items from both channels that share the same key.</li> </ul> <pre><code>Channel.of([1, 'A'], [2, 'B'])\n  .combine(Channel.of([1, 10], [2, 20]), by: 0)\n  .view() // Output: [[1, 'A'], [1, 10]], [[2, 'B'], [2, 20]]\n</code></pre> <p>See also: <code>join</code>. Both relate items from two channels by key, but <code>combine</code> emits all possible pairs for matching keys, while <code>join</code> emits a single joined tuple per key. Example (difference from <code>join</code>):</p> <pre><code>// combine emits all pairs for matching keys\nChannel.of([1, 'A'], [1, 'B'])\n  .combine(Channel.of([1, 10], [1, 20]), by: 0)\n  .view() // Output: [[1, 'A'], [1, 10]], [[1, 'A'], [1, 20]], [[1, 'B'], [1, 10]], [[1, 'B'], [1, 20]]\n// join emits a single joined tuple per key\nChannel.of([1, 'A'], [1, 'B'])\n  .join(Channel.of([1, 10], [1, 20]), by: 0)\n  .view() // Output: [1, 'A', 10], [1, 'B', 20]\n</code></pre>"},{"location":"Operators/#join","title":"join","text":"<p>Use <code>join</code> to enrich or correlate data from two sources, such as joining metadata with results.</p> <ul> <li>Input: Two channels emitting tuples or lists, with a key to match items.</li> <li>Output: A channel emitting joined tuples for each matching key, similar to a database join.</li> </ul> <pre><code>Channel.of([1, 'foo'], [2, 'bar'])\n  .join(Channel.of([1, 30], [2, 40]), by: 0)\n  .view() // Output: [1, 'foo', 30], [2, 'bar', 40]\n</code></pre> <p>See also: <code>combine</code>. Use <code>join</code> for a database-style join (one output per key), while <code>combine</code> can emit multiple pairs for each key. Example (difference from <code>combine</code>):</p> <pre><code>// join emits one joined tuple per key\nChannel.of([2, 'foo'], [2, 'bar'])\n  .join(Channel.of([2, 100], [2, 200]), by: 0)\n  .view() // Output: [2, 'foo', 100], [2, 'bar', 200]\n// combine emits all possible pairs for matching keys\nChannel.of([2, 'foo'], [2, 'bar'])\n  .combine(Channel.of([2, 100], [2, 200]), by: 0)\n  .view() // Output: [[2, 'foo'], [2, 100]], [[2, 'foo'], [2, 200]], [[2, 'bar'], [2, 100]], [[2, 'bar'], [2, 200]]\n</code></pre>"},{"location":"Operators/#cross","title":"cross","text":"<p>Use <code>cross</code> to generate all combinations of two datasets, such as parameter sweeps or matrix builds.</p> <ul> <li>Input: Two channels emitting any type of item.</li> <li>Output: A channel emitting the Cartesian product (all possible pairs) of items from both channels.</li> </ul> <pre><code>Channel.of([1, 'A'], [2, 'B'])\n  .cross(Channel.of([1, 10], [2, 20]))\n  .view() // Output: [[1, 'A'], [1, 10]], [[2, 'B'], [2, 20]]\n</code></pre> <p>See also: <code>combine</code>. <code>cross</code> produces the full Cartesian product of two channels, while <code>combine</code> only pairs items with matching keys. Example (difference from <code>combine</code>):</p> <pre><code>// cross produces all possible pairs (Cartesian product)\nChannel.of(1, 2)\n  .cross(Channel.of('a', 'b'))\n  .view() // Output: [1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']\n// combine only pairs items with matching keys\nChannel.of([1, 'A'], [2, 'B'])\n  .combine(Channel.of([1, 10], [2, 20]), by: 0)\n  .view() // Output: [[1, 'A'], [1, 10]], [[2, 'B'], [2, 20]]\n</code></pre>"},{"location":"Operators/#grouping-and-batching-operators","title":"\ud83d\udce6 Grouping and Batching Operators","text":"<p>These operators group or batch items from a channel. Use them to organize data into manageable sets for downstream processing or aggregation.</p>"},{"location":"Operators/#buffer","title":"buffer","text":"<p>Use <code>buffer</code> to batch items for grouped processing, such as running jobs in chunks or controlling resource usage.</p> <ul> <li>Input: A channel emitting any type of item.</li> <li>Output: A channel emitting lists of items, each list containing up to the specified batch size or meeting a condition.</li> </ul> <pre><code>Channel.of(1, 2, 3, 4, 5)\n  .buffer(size: 2)\n  .view() // Output: [1, 2], [3, 4], [5]\n</code></pre>"},{"location":"Operators/#collate","title":"collate","text":"<p>Use <code>collate</code> to create sliding windows or overlapping groups for analysis or rolling computations.</p> <ul> <li>Input: A channel emitting any type of item.</li> <li>Output: A channel emitting lists of a fixed size, optionally with overlap between groups.</li> </ul> <pre><code>Channel.of(1, 2, 3, 4)\n  .collate(3, 1)\n  .view() // Output: [1, 2, 3], [2, 3, 4]\n</code></pre>"},{"location":"Operators/#grouptuple","title":"groupTuple","text":"<p>Use <code>groupTuple</code> to group related data by a common identifier, such as grouping results by sample or category.</p> <ul> <li>Input: A channel emitting tuples or lists with a key field.</li> <li>Output: A channel emitting pairs of [key, grouped items] where items share the same key.</li> </ul> <pre><code>Channel.of([1, 'A'], [1, 'B'], [2, 'C'])\n  .groupTuple(by: 0)\n  .view() // Output: [1, [[1, 'A'], [1, 'B']]], [2, [[2, 'C']]]\n</code></pre>"},{"location":"Operators/#file-and-data-persistence-operators","title":"\ud83d\udcc1 File and Data Persistence Operators","text":"<p>These operators handle the collection and writing of data to files. Use them to persist results or intermediate data for later use or external analysis.</p>"},{"location":"Operators/#collectfile","title":"collectFile","text":"<p>Use <code>collectFile</code> to save all channel items to a file for reporting, archiving, or downstream tools.</p> <ul> <li>Input: A channel emitting any type of item.</li> <li>Output: A file containing all items, typically one per line or as specified.</li> </ul> <pre><code>Channel.of('foo', 'bar')\n  .collectFile(name: 'output.txt')\n// Writes 'foo' and 'bar' to output.txt\n</code></pre>"},{"location":"Operators/#save","title":"save","text":"<p>Use <code>save</code> to persist results or logs to a specific file location for reproducibility or sharing.</p> <ul> <li>Input: A channel emitting any type of item.</li> <li>Output: A file at the specified path containing all items.</li> </ul> <pre><code>Channel.of(1, 2, 3)\n  .save('numbers.txt')\n// Writes 1, 2, 3 to numbers.txt\n</code></pre>"},{"location":"Operators/#mathematical-and-statistical-operators","title":"\ud83e\uddee Mathematical and Statistical Operators","text":"<p>These operators perform mathematical computations on channel items. Use them to summarize, analyze, or reduce data streams.</p>"},{"location":"Operators/#count","title":"count","text":"<p>Use <code>count</code> to determine the size of a dataset or the number of results produced by a process.</p> <ul> <li>Input: A channel emitting any type of item.</li> <li>Output: A channel emitting a single integer representing the number of items received.</li> </ul> <pre><code>Channel.of(1, 2, 3)\n  .count()\n  .view() // Output: 3\n</code></pre>"},{"location":"Operators/#sum","title":"sum","text":"<p>Use <code>sum</code> to calculate totals, such as the sum of measurements or scores.</p> <ul> <li>Input: A channel emitting numeric items.</li> <li>Output: A channel emitting a single value representing the sum of all items.</li> </ul> <pre><code>Channel.of(1, 2, 3)\n  .sum()\n  .view() // Output: 6\n</code></pre>"},{"location":"Operators/#min","title":"min","text":"<p>Use <code>min</code> to find the smallest value in a dataset, such as the lowest score or measurement.</p> <ul> <li>Input: A channel emitting comparable items (e.g., numbers).</li> <li>Output: A channel emitting the minimum value among all items.</li> </ul> <pre><code>Channel.of(5, 2, 8)\n  .min()\n  .view() // Output: 2\n</code></pre>"},{"location":"Operators/#max","title":"max","text":"<p>Use <code>max</code> to find the largest value in a dataset, such as the highest score or measurement.</p> <ul> <li>Input: A channel emitting comparable items (e.g., numbers).</li> <li>Output: A channel emitting the maximum value among all items.</li> </ul> <pre><code>Channel.of(5, 2, 8)\n  .max()\n  .view() // Output: 8\n</code></pre>"},{"location":"Operators/#mean","title":"mean","text":"<p>Use <code>mean</code> to calculate the average of a set of values, such as mean coverage or expression.</p> <ul> <li>Input: A channel emitting numeric items.</li> <li>Output: A channel emitting the average (mean) value of all items.</li> </ul> <pre><code>Channel.of(2, 4, 6)\n  .mean()\n  .view() // Output: 4.0\n</code></pre>"},{"location":"Operators/#testing-and-debugging-operators","title":"\ud83e\uddea Testing and Debugging Operators","text":"<p>These operators assist in testing and debugging workflows.</p>"},{"location":"Operators/#view","title":"view","text":"<p>Use <code>view</code> to print items to the console for inspection.</p> <pre><code>Channel.of('foo', 'bar')\n  .view() // Output: foo, bar\n</code></pre>"},{"location":"Operators/#subscribe","title":"subscribe","text":"<p>Use <code>subscribe</code> to perform actions on emitted items.</p> <pre><code>Channel.of(1, 2, 3)\n  .subscribe { println \"Item: $it\" }\n// Output: Item: 1\\nItem: 2\\nItem: 3\n</code></pre>"}]}